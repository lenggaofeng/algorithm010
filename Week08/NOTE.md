学习笔记

# 位运算符
`>>` 右移， 除以2
`<<` 左移， 乘以2
`&` 按位与, 有一个为0，则为0
`|` 按位或，有一个为1，则为1
`~` 非， 取反
`^` 异或， 相同为0， 不同为1
## 异或高级操作
异或，相同为0， 不同为 1, 可以理解为`不进位的加法`。
`x^0=x`
`x^1s=~x` 1s 表示全为 1 
`x^~x=1s`
`x^x=0`
`c=a^b => a^c=b, b^c=a` 可以用来交换两个数
`a^b^c=(a^b)^c=a^(b^c)`

## 实战操作


# 布隆过滤器
简单来说， 就是把一个数据， 按位拆分成多个标记位并存储。 
想判断数据存不存在的时候, 只需要判断它的每个位标记位是不是存在，如果有一个不存在的话，那么数据肯定不存在。
但是这个方法不能确定数据存在， 因此只能做一个粗略的判断。 常用于查询数据之前的一个快速缓冲判断。

# LRU Cache
因为 `cache` 容量有限，所以需要设计一个替换算法， 来提高 `cache` 的命中率。
`LRU` 的意思是 "Latest Recent Used" 表示最近最少使用。
常用实现思路是 `HashMap` + `双向链表`;

# 排序算法
排序算法常分为 `比较类排序` 和 `非比较类排序` 两种。
# 比较类排序
比较类排序的时间复杂度不优于 `nlogn`, 但是逻辑更通用， 所以被广泛使用。
常见的有:
+ 选择排序
每次从未排部分选择一个最小的元素， 替换到数组的最前面，循环`n`次，即可完成排序。
+ 插入排序
对于未排序部分， 将它插入到前方已排序部分，并保持有序部分的顺序。 
插入的位置可以用二分查找，但是每一轮移动数组的复杂度是 `O(n)`, 所以总的时间复杂度还是 `O(n^2)`;
+ 冒泡排序
每次遍历， 遇到顺序相反的元素就交换， 这样一轮下来，最大的元素会被交换到最后面，就像水里的气泡， 所以叫冒泡排序。
这个思路与选择排序正好相反, 平均时间复杂度也是 `O(n^2)`
+ 堆排序
使用堆的特性，将所有数据全部插入进去， 然后再挨个取出， 数组就是有序的了。
+ 快速排序
分治的思想， 根据基准点， 每次把数据分割成比它小的部分和比它大的部分， 对这两部分再使用快排的思想。 最后整个数组就是有序的了。
平均时间复杂度为 `O(nlogn)`, 最坏时间复杂度为 `O(n^2)`
+ 归并排序
也是分治的思想，与快排不同的是， 它把数据分割成两个相同的大小的子序列， 然后对这两个子序列进行归并排序， 最后把两个有序的子序列进行合并。
比快排稳定。
平均时间复杂度为 `O(nlogn)`, 最坏时间复杂度也是`O(nlogn)`

## 非比较类排序
只能对`int`类型的数据使用。
+ 计数排序
+ 桶排序
+ 基数排序